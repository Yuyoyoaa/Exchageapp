This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
BackEnd/
  config/
    config.go
    config.yml
    db.go
    redis.go
  controllers/
    admin_controllers.go
    article_controllers.go
    auth_controllers.go
    category_controllers.go
    comment_controllers.go
    exchange_rate_controllers.go
    like_controllers.go
  global/
    global.go
  middlewares/
    auth_middlewares.go
    role_middlewares.go
  models/
    article_like.go
    article.go
    category.go
    comment.go
    exchange_rate.go
    favorite.go
    user.go
  router/
    router.go
  utils/
    utils.go
  .prettierrc.json
  Dockerfile
  go.mod
  main.go
  repomix-output.xml
FrontEnd/
  src/
    components/
      Login.vue
      Register.vue
    router/
      index.ts
    store/
      auth.ts
    types/
      Article.d.ts
      User.d.ts
    views/
      AdminUserView.vue
      CurrencyExchangeView.vue
      HomeView.vue
      NewsDetailView.vue
      NewsView.vue
      ProfileView.vue
    App.vue
    axios.ts
    main.ts
    shims-vue.d.ts
    vite-env.d.ts
  __VLS_types.d.ts
  index.html
  package.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
docker-compose.yml
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="BackEnd/config/config.go">
package config

import (
	"log"

	"github.com/spf13/viper"
)

// 将配置文件赋值给自定义的结构体
type Config struct {
	App struct {
		Name string `yaml:"name"`
		Port string `yaml:"port"`
	} `yaml:"app"`
	Database struct {
		Dsn          string `yaml:"dsn"`
		MaxIdleCONNS int    `yaml:"MaxIdleCONNS"`
		MaxOpenCONNS int    `yaml:"MaxOpenCONNS"`
	}
	Redis struct {
		Addr     string `yaml:"addr"`
		Password string `yaml:"password"`
		DB       int    `yaml:"db"`
	} `yaml:"redis"`
}

var AppConfig *Config

func InitConfig() {
	viper.SetConfigName("config")
	viper.SetConfigType("yml")
	viper.AddConfigPath("./config")

	if err := viper.ReadInConfig(); err != nil {
		log.Fatalf("Error Reading Config file: %v", err)
	}

	AppConfig = &Config{}

	if err := viper.Unmarshal(AppConfig); err != nil {
		log.Fatalf("Unable to decode into struct: %v", err)
	}

	InitDB()
	InitRedis()
}
</file>

<file path="BackEnd/config/config.yml">
app:
  name: 'CurrencyExchangeApp'
  port: '3080'

database:
  dsn: 'root:123@tcp(mysql:3306)/exchangeApp?charset=utf8mb4&parseTime=True&loc=Local'
  MaxIdleCONNS: 10
  MaxOpenCONNS: 100

redis:
  addr: 'redis:6379'
  password: ''
  db: 0
</file>

<file path="BackEnd/config/db.go">
package config

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"fmt"
	"log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func InitDB() {
	dsn := AppConfig.Database.Dsn
	fmt.Println("DSN:", dsn)
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("Failed to initialize database, got error: %v", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		log.Fatalf("Failed to configure database, got error: %v", err)
	}

	sqlDB.SetMaxIdleConns(AppConfig.Database.MaxIdleCONNS)
	sqlDB.SetMaxOpenConns(AppConfig.Database.MaxOpenCONNS)
	sqlDB.SetConnMaxLifetime(time.Hour)

	global.Db = db

	// 迁移模型
	if err := global.Db.AutoMigrate(
		&models.User{},
		&models.Article{},
		&models.Category{},
		&models.ArticleLike{},
		&models.Favorite{},
		&models.Comment{},
		&models.ExchangeRate{},
	); err != nil {
		log.Fatalf("Failed to migrate database, got error: %v", err)
	}

	// 为 likes 添加唯一索引（兼容不同 gorm 版本的写法，若报错可删）：
	_ = global.Db.Exec("CREATE UNIQUE INDEX IF NOT EXISTS idx_user_article ON article_likes (user_id, article_id);")

	fmt.Println("Database initialized and migrated successfully")
}
</file>

<file path="BackEnd/config/redis.go">
package config

import (
	"context"
	"exchangeapp/global"
	"log"

	"github.com/redis/go-redis/v9"
)

func InitRedis() {
	ctx := context.Background()
	RedisClient := redis.NewClient(&redis.Options{
		Addr:     AppConfig.Redis.Addr,
		Password: AppConfig.Redis.Password,
		DB:       AppConfig.Redis.DB,
	})

	_, err := RedisClient.Ping(ctx).Result()

	if err != nil {
		log.Fatalf("Failed to connect to Redis,got error: %v", err)
	}

	global.RedisDB = RedisClient
}
</file>

<file path="BackEnd/controllers/admin_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"

	"github.com/gin-gonic/gin"
)

// GetUserList 获取所有用户列表 (仅管理员)
func GetUserList(ctx *gin.Context) {
	var users []models.User
	// 查询所有用户，排除密码字段
	// Select 语法取决于 GORM 版本，这里使用简单查询后手动清空密码，或者使用 Smart Select
	if err := global.Db.Find(&users).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 处于安全考虑，清空密码和敏感信息
	var safeUsers []map[string]interface{}
	for _, u := range users {
		safeUsers = append(safeUsers, map[string]interface{}{
			"ID":        u.ID,
			"username":  u.Username,
			"nickname":  u.Nickname,
			"email":     u.Email,
			"role":      u.Role,
			"avatar":    u.Avatar,
			"CreatedAt": u.CreatedAt,
		})
	}

	ctx.JSON(http.StatusOK, safeUsers)
}

// UpdateUserRole 修改用户角色 (仅管理员)
func UpdateUserRole(ctx *gin.Context) {
	// 1. 获取目标用户 ID
	targetUserID := ctx.Param("id")

	// 2. 获取请求体中的新角色
	var input struct {
		Role string `json:"role" binding:"required"` // 只允许 "admin" 或 "user"
	}
	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 简单校验角色合法性
	if input.Role != "admin" && input.Role != "user" {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role value"})
		return
	}

	// 3. 查找并更新用户
	var user models.User
	if err := global.Db.First(&user, targetUserID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// 防止自我降级 (可选：防止管理员不小心把自己改成 user 后失去权限)
	currentUsername := ctx.GetString("username")
	if user.Username == currentUsername && input.Role == "user" {
		ctx.JSON(http.StatusForbidden, gin.H{"error": "You cannot demote yourself"})
		return
	}

	// 更新数据库
	if err := global.Db.Model(&user).Update("role", input.Role).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"message":  "Role updated successfully",
		"user_id":  user.ID,
		"new_role": input.Role,
	})
}

// DeleteUser 删除用户 (仅管理员)
func DeleteUser(ctx *gin.Context) {
	// 目标用户 ID（要删除谁）
	targetID := ctx.Param("id")

	// 当前正在操作的管理员 ID（从 Token 获取）
	currentUserID := ctx.GetString("userID")

	// 防止删除自己
	if currentUserID == targetID {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": "不能删除自己的账号",
		})
		return
	}

	// 检查用户是否存在
	var user models.User
	if err := global.Db.First(&user, targetID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
		return
	}

	// 删除用户
	if err := global.Db.Delete(&models.User{}, targetID).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}
</file>

<file path="BackEnd/controllers/article_controllers.go">
package controllers

import (
	"context"
	"encoding/json"
	"errors"
	"exchangeapp/global"
	"exchangeapp/models"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

var ctxRedis = context.Background()

const (
	ArticleListCachePrefix = "articles:list:"   // 分页+分类
	ArticleSingleCache     = "articles:single:" // 单篇文章缓存
	ArticleHotCache        = "articles:hot"     // 热门文章缓存
	CacheExpire            = 10 * time.Minute
)

// ======== 管理员文章操作 ========

func CreateArticle(ctx *gin.Context) {
	var article models.Article
	if err := ctx.ShouldBindJSON(&article); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	article.AuthorID = ctx.GetUint("userID")

	if err := global.Db.Create(&article).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	clearArticleCache()
	ctx.JSON(http.StatusCreated, article)
}

func UpdateArticle(ctx *gin.Context) {
	articleID := ctx.Param("id")
	var req models.Article
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var article models.Article
	if err := global.Db.First(&article, articleID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "文章不存在"})
		return
	}

	article.Title = req.Title
	article.Content = req.Content
	article.Preview = req.Preview
	article.Cover = req.Cover
	article.CategoryID = req.CategoryID
	article.Status = req.Status

	if err := global.Db.Save(&article).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	clearArticleCacheByID(articleID)
	ctx.JSON(http.StatusOK, gin.H{"message": "文章已更新", "data": article})
}

func DeleteArticle(ctx *gin.Context) {
	articleID := ctx.Param("id")
	if err := global.Db.Delete(&models.Article{}, articleID).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "删除失败"})
		return
	}

	clearArticleCacheByID(articleID)
	ctx.JSON(http.StatusOK, gin.H{"message": "文章已删除"})
}

// ======== 文章列表（分页 + 分类 + 缓存） ========

func GetArticles(ctx *gin.Context) {
	pageStr := ctx.DefaultQuery("page", "1")
	limitStr := ctx.DefaultQuery("limit", "10")
	category := ctx.Query("category")

	page, _ := strconv.Atoi(pageStr)
	limit, _ := strconv.Atoi(limitStr)

	cacheKey := fmt.Sprintf("%s%s:page_%d:limit_%d", ArticleListCachePrefix, category, page, limit)

	cached, err := global.RedisDB.Get(ctxRedis, cacheKey).Result()
	if err == nil {
		var articles []models.Article
		if json.Unmarshal([]byte(cached), &articles) == nil {
			ctx.JSON(http.StatusOK, articles)
			return
		}
	}

	var articles []models.Article
	db := global.Db
	if category != "" {
		db = db.Where("category_id = ?", category)
	}
	db = db.Offset((page - 1) * limit).Limit(limit).Order("created_at DESC")
	if err := db.Find(&articles).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	data, _ := json.Marshal(articles)
	global.RedisDB.Set(ctxRedis, cacheKey, data, CacheExpire)
	ctx.JSON(http.StatusOK, articles)
}

// ======== 单篇文章缓存 + 浏览量 ========

func GetArticleByID(ctx *gin.Context) {
	id := ctx.Param("id")
	cacheKey := ArticleSingleCache + id

	cached, err := global.RedisDB.Get(ctxRedis, cacheKey).Result()
	if err == nil {
		var article models.Article
		if json.Unmarshal([]byte(cached), &article) == nil {
			global.Db.Model(&article).UpdateColumn("views_count", gorm.Expr("views_count + ?", 1))
			ctx.JSON(http.StatusOK, article)
			return
		}
	}

	var article models.Article
	if err := global.Db.First(&article, id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			ctx.JSON(http.StatusNotFound, gin.H{"error": "文章不存在"})
		} else {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	global.Db.Model(&article).UpdateColumn("views_count", gorm.Expr("views_count + ?", 1))

	data, _ := json.Marshal(article)
	global.RedisDB.Set(ctxRedis, cacheKey, data, CacheExpire)
	ctx.JSON(http.StatusOK, article)
}

// ======== 热门文章（按 views_count 排序前 10） ========

func GetHotArticles(ctx *gin.Context) {
	cached, err := global.RedisDB.Get(ctxRedis, ArticleHotCache).Result()
	if err == nil {
		var articles []models.Article
		if json.Unmarshal([]byte(cached), &articles) == nil {
			ctx.JSON(http.StatusOK, articles)
			return
		}
	}

	var articles []models.Article
	if err := global.Db.Order("views_count DESC").Limit(10).Find(&articles).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	data, _ := json.Marshal(articles)
	global.RedisDB.Set(ctxRedis, ArticleHotCache, data, CacheExpire)
	ctx.JSON(http.StatusOK, articles)
}

// ======== 收藏 ========

func ToggleFavorite(ctx *gin.Context) {
	userID := ctx.GetUint("userID")
	articleIDStr := ctx.Param("id")
	articleID, _ := strconv.Atoi(articleIDStr)

	var fav models.Favorite
	err := global.Db.Where("user_id = ? AND article_id = ?", userID, articleID).First(&fav).Error
	if err == nil {
		// 已收藏，取消
		global.Db.Delete(&fav)
		ctx.JSON(http.StatusOK, gin.H{"message": "取消收藏"})
		return
	}

	// 创建收藏
	fav = models.Favorite{UserID: userID, ArticleID: uint(articleID)}
	if err := global.Db.Create(&fav).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"message": "收藏成功"})
}

// ======== 辅助函数：缓存清理 ========

func clearArticleCache() {
	keys := global.RedisDB.Keys(ctxRedis, ArticleListCachePrefix+"*").Val()
	for _, k := range keys {
		global.RedisDB.Del(ctxRedis, k)
	}
	global.RedisDB.Del(ctxRedis, ArticleHotCache)
}

func clearArticleCacheByID(id string) {
	global.RedisDB.Del(ctxRedis, ArticleSingleCache+id)
	clearArticleCache()
}
</file>

<file path="BackEnd/controllers/auth_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"exchangeapp/utils"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func Register(ctx *gin.Context) {
	var input struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
		Role     string `json:"role"` // 可选
		Nickname string `json:"nickname"`
		Email    string `json:"email" binding:"email"`
		Avatar   string `json:"avatar"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 验证角色合法性
	if input.Role != "" && input.Role != "admin" && input.Role != "user" {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role value"})
		return
	}

	if !utils.ValidatePassword(input.Password) {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": "密码至少8位，必须包含大写字母、小写字母和数字",
		})
		return
	}

	hashedPwd, err := utils.HashPassword(input.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user := models.User{
		Username: input.Username,
		Password: hashedPwd,
		Role:     input.Role,
		Nickname: input.Nickname,
		Email:    input.Email,
		Avatar:   input.Avatar,
	}

	if user.Role == "" {
		user.Role = "user"
	}

	// 检查用户名和邮箱是否已存在
	var existingUser models.User
	if err := global.Db.Where("username = ? OR email = ?", user.Username, user.Email).First(&existingUser).Error; err == nil {
		if existingUser.Username == user.Username {
			ctx.JSON(http.StatusBadRequest, gin.H{"error": "用户名已存在"})
		} else {
			ctx.JSON(http.StatusBadRequest, gin.H{"error": "邮箱已存在"})
		}
		return
	}

	if err := global.Db.Create(&user).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	token, err := utils.GenerateJWT(user.Username)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user.Password = "" // 不返回密码
	ctx.JSON(http.StatusOK, gin.H{"token": token, "user": user})
}

func Login(ctx *gin.Context) {
	// 登录过程的用户名和密码
	var input struct {
		Username string `json:"username"` // 结构体标签(方便将json字段映射到结构体)
		Password string `json:"password"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	var user models.User

	// 验证用户名
	if err := global.Db.Where("username = ?", input.Username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusUnauthorized, gin.H{
			"error": "wrong credentials",
		})
		return
	}

	key := "login_fail:" + input.Username
	failCount, _ := global.RedisDB.Get(ctx, key).Int()
	if failCount >= 5 {
		ctx.JSON(http.StatusForbidden, gin.H{"error": "尝试次数过多，请15分钟后再试"})
		return
	}

	if !utils.CheckPassword(input.Password, user.Password) {
		// 登录失败时
		global.RedisDB.Incr(ctx, key)
		global.RedisDB.Expire(ctx, key, time.Minute*15)
		ctx.JSON(http.StatusUnauthorized, gin.H{
			"error": "wrong credentials",
		})
		return
	}

	// 登录成功，删除失败计数
	global.RedisDB.Del(ctx, key)

	token, err := utils.GenerateJWT(user.Username)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"token": token})
}

// 新增获取/更新用户信息接口
func GetProfile(ctx *gin.Context) {
	username := ctx.GetString("username")
	var user models.User
	if err := global.Db.Where("username = ?", username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
		return
	}
	user.Password = "" // 不返回密码
	ctx.JSON(http.StatusOK, user)
}

func UpdateProfile(ctx *gin.Context) {
	username := ctx.GetString("username")

	var input struct {
		Nickname string `json:"nickname"`
		Email    string `json:"email" binding:"email"`
		Avatar   string `json:"avatar"`
		Password string `json:"password"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var user models.User
	if err := global.Db.Where("username = ?", username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
		return
	}

	if input.Nickname != "" {
		user.Nickname = input.Nickname
	}

	if input.Email != "" {
		user.Email = input.Email
	}

	if input.Avatar != "" {
		user.Avatar = input.Avatar
	}

	if input.Password != "" {
		// 校验密码强度
		if !utils.ValidatePassword(input.Password) {
			ctx.JSON(http.StatusBadRequest, gin.H{
				"error": "密码至少8位，必须包含大写字母、小写字母和数字",
			})
			return
		}

		hashedPwd, err := utils.HashPassword(input.Password)
		if err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		user.Password = hashedPwd
	}

	if err := global.Db.Save(&user).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user.Password = ""
	ctx.JSON(http.StatusOK, user)
}
</file>

<file path="BackEnd/controllers/category_controllers.go">
package controllers

import (
	"encoding/json"
	"errors"
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

const CategoryCacheKey = "categories:list"

// ===== 公共接口 =====
func GetCategories(ctx *gin.Context) {
	// 尝试从缓存获取
	cached, err := global.RedisDB.Get(ctxRedis, CategoryCacheKey).Result()
	if err == nil {
		var categories []models.Category
		if json.Unmarshal([]byte(cached), &categories) == nil {
			ctx.JSON(http.StatusOK, categories)
			return
		}
	}

	// 缓存未命中，查询数据库
	var categories []models.Category
	if err := global.Db.Order("id ASC").Find(&categories).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 写入缓存
	data, _ := json.Marshal(categories)
	global.RedisDB.Set(ctxRedis, CategoryCacheKey, data, CacheExpire)

	ctx.JSON(http.StatusOK, categories)
}

// ===== 管理员接口 =====
func CreateCategory(ctx *gin.Context) {
	var category models.Category
	if err := ctx.ShouldBindJSON(&category); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := global.Db.Create(&category).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 清除缓存，下次读取刷新
	global.RedisDB.Del(ctxRedis, CategoryCacheKey)

	ctx.JSON(http.StatusCreated, category)
}

func DeleteCategory(ctx *gin.Context) {
	idStr := ctx.Param("id")
	id, _ := strconv.Atoi(idStr)

	var category models.Category
	if err := global.Db.First(&category, id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			ctx.JSON(http.StatusNotFound, gin.H{"error": "分类不存在"})
		} else {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	if err := global.Db.Delete(&category).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "删除失败"})
		return
	}

	// 清除缓存
	global.RedisDB.Del(ctxRedis, CategoryCacheKey)

	ctx.JSON(http.StatusOK, gin.H{"message": "分类已删除"})
}
</file>

<file path="BackEnd/controllers/comment_controllers.go">
package controllers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"exchangeapp/global"
	"exchangeapp/models"

	"github.com/gin-gonic/gin"
)

const (
	CommentCachePrefix = "comments:article:" // 每篇文章的评论缓存 key
)

// ======== 创建评论 ========
func CreateComment(ctx *gin.Context) {
	userID := ctx.GetUint("userID")
	userName := ctx.GetString("userName")
	articleIDStr := ctx.Param("id")
	articleID, _ := strconv.Atoi(articleIDStr)

	var comment models.Comment
	if err := ctx.ShouldBindJSON(&comment); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	comment.ArticleID = uint(articleID)
	comment.UserID = userID
	comment.UserName = userName

	if err := global.Db.Create(&comment).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 新增评论后清理文章所有分页缓存
	clearCommentCache(uint(articleID))

	ctx.JSON(http.StatusCreated, comment)
}

// ======== 删除自己的评论 ========
func DeleteComment(ctx *gin.Context) {
	userID := ctx.GetUint("userID")
	commentID := ctx.Param("id")

	var comment models.Comment
	if err := global.Db.First(&comment, commentID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "评论不存在"})
		return
	}

	if comment.UserID != userID {
		ctx.JSON(http.StatusForbidden, gin.H{"error": "只能删除自己的评论"})
		return
	}

	// 软删除
	if err := global.Db.Delete(&comment).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "删除失败"})
		return
	}

	// 删除该文章的所有分页缓存
	clearCommentCache(comment.ArticleID)

	ctx.JSON(http.StatusOK, gin.H{"message": "评论已删除"})
}

// ======== 管理员强制删除评论 ========
func ForceDeleteComment(ctx *gin.Context) {
	commentID := ctx.Param("id")

	var comment models.Comment
	if err := global.Db.First(&comment, commentID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "评论不存在"})
		return
	}

	global.Db.Delete(&comment)
	clearCommentCache(comment.ArticleID)

	ctx.JSON(http.StatusOK, gin.H{"message": "评论已删除"})
}

// ======== 获取文章评论（支持分页） ========
func GetCommentsByArticleID(ctx *gin.Context) {
	articleIDStr := ctx.Param("id")
	pageStr := ctx.DefaultQuery("page", "1")
	limitStr := ctx.DefaultQuery("limit", "10")

	page, _ := strconv.Atoi(pageStr)
	limit, _ := strconv.Atoi(limitStr)
	offset := (page - 1) * limit

	cacheKey := fmt.Sprintf("%s%s:page_%d:limit_%d", CommentCachePrefix, articleIDStr, page, limit)

	// 尝试读取缓存
	cached, err := global.RedisDB.Get(ctxRedis, cacheKey).Result()
	if err == nil {
		var comments []models.Comment
		if json.Unmarshal([]byte(cached), &comments) == nil {
			ctx.JSON(http.StatusOK, comments)
			return
		}
	}

	// 缓存不存在或解析失败，从数据库读取
	var comments []models.Comment
	if err := global.Db.
		Where("article_id = ?", articleIDStr).
		Offset(offset).Limit(limit).
		Order("created_at ASC").
		Find(&comments).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 写入缓存
	data, _ := json.Marshal(comments)
	global.RedisDB.Set(ctxRedis, cacheKey, data, CacheExpire)

	ctx.JSON(http.StatusOK, comments)
}

// ======== 辅助函数：清理某文章的所有分页评论缓存 ========
func clearCommentCache(articleID uint) {
	pattern := fmt.Sprintf("%s%d:page_*", CommentCachePrefix, articleID)
	keys, _ := global.RedisDB.Keys(ctxRedis, pattern).Result()
	for _, k := range keys {
		global.RedisDB.Del(ctxRedis, k)
	}
}
</file>

<file path="BackEnd/controllers/exchange_rate_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func CreateExchangeRate(ctx *gin.Context) {
	var exchangeRate models.ExchangeRate

	if err := ctx.ShouldBindJSON(&exchangeRate); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	exchangeRate.Date = time.Now()

	if err := global.Db.Create(&exchangeRate).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"message": "汇率创建成功",
		"data":    exchangeRate,
	})
}

func GetExchangeRates(ctx *gin.Context) {
	var exchangeRates []models.ExchangeRate

	if err := global.Db.Find(&exchangeRates).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}
	ctx.JSON(http.StatusOK, exchangeRates)
}
</file>

<file path="BackEnd/controllers/like_controllers.go">
package controllers

import (
	"context"
	"errors"
	"exchangeapp/global"
	"exchangeapp/models"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
)

func LikeArticle(ctx *gin.Context) {
	userID := ctx.GetUint("userID")
	articleID := ctx.Param("id")

	// Redis key
	likeCountKey := fmt.Sprintf("article:%s:likes_count", articleID)
	userSetKey := fmt.Sprintf("article:%s:liked_users", articleID)

	var article models.Article
	if err := global.Db.First(&article, articleID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			ctx.JSON(http.StatusNotFound, gin.H{"error": "文章不存在"})
			return
		}
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 检查用户是否已经点赞
	exists, err := global.RedisDB.SIsMember(ctx.Request.Context(), userSetKey, userID).Result()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	if exists {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "你已点赞过"})
		return
	}

	// 将用户加入已点赞集合
	if err := global.RedisDB.SAdd(ctx.Request.Context(), userSetKey, userID).Err(); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	// 设置集合过期时间，防止无限增长
	global.RedisDB.Expire(ctx.Request.Context(), userSetKey, 24*time.Hour*30)

	// 点赞计数 +1
	newCount, err := global.RedisDB.Incr(ctx.Request.Context(), likeCountKey).Result()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	// 设置过期时间，确保同步数据库后仍能缓存热点数据
	global.RedisDB.Expire(ctx.Request.Context(), likeCountKey, 24*time.Hour*30)

	ctx.JSON(http.StatusOK, gin.H{
		"message":    "点赞成功",
		"likesCount": newCount,
	})
}

// 后台定时同步 Redis 点赞到数据库
func SyncLikesToDB() {
	for {
		time.Sleep(5 * time.Minute) // 每5分钟同步一次
		var articles []models.Article
		global.Db.Find(&articles)

		for _, a := range articles {
			likeKey := fmt.Sprintf("article:%d:likes_count", a.ID)
			ctx := context.Background() // ✅ 这里创建 context

			countStr, err := global.RedisDB.Get(ctx, likeKey).Result()
			if err == nil {
				count, _ := strconv.ParseInt(countStr, 10, 64)
				global.Db.Model(&a).UpdateColumn("likes_count", count)
			}
		}
	}
}

func GetArticleLikes(ctx *gin.Context) {
	articleID := ctx.Param("id")
	likeKey := fmt.Sprintf("article:%s:likes_count", articleID)

	countStr, err := global.RedisDB.Get(ctx.Request.Context(), likeKey).Result()
	if err == redis.Nil {
		// 缓存不存在，读取数据库
		var article models.Article
		if err := global.Db.Select("likes_count").First(&article, articleID).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				ctx.JSON(http.StatusNotFound, gin.H{"error": "文章不存在"})
			} else {
				ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			}
			return
		}
		countStr = strconv.FormatInt(article.LikesCount, 10)
		// 写入 Redis 缓存
		global.RedisDB.Set(ctx.Request.Context(), likeKey, countStr, 24*time.Hour*30)
	} else if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"likesCount": countStr})
}
</file>

<file path="BackEnd/global/global.go">
package global

import (
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
)

// 全局变量
var (
	Db      *gorm.DB
	RedisDB *redis.Client
)
</file>

<file path="BackEnd/middlewares/auth_middlewares.go">
package middlewares

import (
	"exchangeapp/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

// 验证JWT是否有效

func AuthMiddleWare() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		token := ctx.GetHeader("Authorization")
		if token == "" {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"error": "Authorization header is required",
			})
			ctx.Abort() // 阻止后续的中间件和处理函数执行,但不会中断当前函数中 ctx.Abort()之后的代码执行
			return
		}
		username, err := utils.ParseJWT(token)

		if err != nil {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid token: " + err.Error(),
			})
			ctx.Abort()
			return
		}

		ctx.Set("username", username) // 用于在不同中间件传递kv数据
		ctx.Next()

	}
}
</file>

<file path="BackEnd/middlewares/role_middlewares.go">
package middlewares

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"

	"github.com/gin-gonic/gin"
)

// 检查角色
func AdminMiddleware() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		username, exists := ctx.Get("username")
		if !exists {
			ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			ctx.Abort()
			return
		}
		var user models.User
		if err := global.Db.Where("username = ?", username.(string)).First(&user).Error; err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": "User not found"})
			ctx.Abort()
			return
		}
		if user.Role != "admin" {
			ctx.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			ctx.Abort()
			return
		}
		ctx.Next()
	}
}
</file>

<file path="BackEnd/models/article_like.go">
package models

import "gorm.io/gorm"

// 点赞记录，确保每用户对每文章唯一
type ArticleLike struct {
	gorm.Model
	UserID    uint `gorm:"index;not null"`
	ArticleID uint `gorm:"index;not null"`
}

// 在迁移或 DB 初始化后，为 (user_id, article_id) 添加唯一索引：
// db.Model(&models.ArticleLike{}).AddUniqueIndex("idx_user_article", "user_id", "article_id")
</file>

<file path="BackEnd/models/article.go">
package models

import "gorm.io/gorm"

type Article struct {
	gorm.Model
	Title      string `json:"title" binding:"required"`
	Content    string `json:"content" binding:"required"`
	Preview    string `json:"preview" binding:"required"`
	Cover      string `json:"cover,omitempty"`
	LikesCount int64  `gorm:"default:0" json:"likesCount"`
	ViewsCount int64  `gorm:"default:0" json:"viewsCount"`
	AuthorID   uint   `json:"authorId"`             // 创建者（通常为 admin）
	CategoryID uint   `json:"categoryId,omitempty"` // 分类
	Status     string `gorm:"default:'published'" json:"status"`
}
</file>

<file path="BackEnd/models/category.go">
package models

type Category struct {
	ID   uint   `gorm:"primaryKey" json:"id"`
	Name string `gorm:"unique;not null" json:"name"`
}
</file>

<file path="BackEnd/models/comment.go">
package models

import "gorm.io/gorm"

type Comment struct {
	gorm.Model
	ArticleID uint   `json:"articleId" gorm:"index;not null"`
	UserID    uint   `json:"userId" gorm:"index;not null"`
	UserName  string `json:"userName"`
	Content   string `json:"content" binding:"required"`
	ParentID  *uint  `json:"parentId,omitempty"` // 支持二级回复
}
</file>

<file path="BackEnd/models/exchange_rate.go">
package models

import "time"

type ExchangeRate struct {
	ID           uint      `gorm:"primaryKey" json:"id"`
	FromCurrency string    `json:"fromCurrency" binding:"required"`
	ToCurrency   string    `json:"toCurrency" binding:"required"`
	Rate         float64   `json:"rate" binding:"required"`
	Date         time.Time `json:"date"`
}
</file>

<file path="BackEnd/models/favorite.go">
package models

import "gorm.io/gorm"

// 收藏记录
type Favorite struct {
	gorm.Model
	UserID    uint `gorm:"index;not null"`
	ArticleID uint `gorm:"index;not null"`
}
</file>

<file path="BackEnd/models/user.go">
package models

import "gorm.io/gorm"

type User struct {
	gorm.Model
	Username string `gorm:"unique" json:"username" binding:"required"`
	Password string `json:"-" binding:"required"`
	Role     string `gorm:"default:'user'" json:"role"` // user/admin
	Nickname string `json:"nickname"`                   // 昵称
	Email    string `gorm:"unique" json:"email"`        // 可为空，不强制验证
	Avatar   string `json:"avatar"`                     // 头像
}

/*Role 默认是普通用户 user，管理员为 admin

Password 不在 JSON 输出中显示（json:"-"）

Nickname, Email, Avatar 可以为空 */
</file>

<file path="BackEnd/router/router.go">
package router

import (
	"exchangeapp/controllers"
	"exchangeapp/middlewares"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

func SetupRouter() *gin.Engine {
	r := gin.Default()

	// CORS 配置
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:5173", "http://127.0.0.1:5173"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	// ===== 用户注册登录 =====
	auth := r.Group("/api/auth")
	{
		auth.POST("/login", controllers.Login)
		auth.POST("/register", controllers.Register)
	}

	// ===== 公共 API =====
	api := r.Group("/api")
	{
		api.GET("/exchangeRates", controllers.GetExchangeRates)

		// 文章公共接口（无需登录）
		api.GET("/articles", controllers.GetArticles)        // 分页 + 分类
		api.GET("/articles/:id", controllers.GetArticleByID) // 文章详情（自动 views++）
		api.GET("/articles/:id/comments", controllers.GetCommentsByArticleID)
		api.GET("/categories", controllers.GetCategories)
		api.GET("/articles/:id/like", controllers.GetArticleLikes)
	}

	// ===== 需要认证的接口 =====
	authAPI := api.Group("")
	authAPI.Use(middlewares.AuthMiddleWare())
	{
		// 普通用户操作（点赞、评论）
		authAPI.POST("/articles/:id/like", controllers.LikeArticle)        // 每用户只能点赞一次
		authAPI.POST("/articles/:id/favorite", controllers.ToggleFavorite) // 收藏/取消收藏
		authAPI.POST("/articles/:id/comments", controllers.CreateComment)  // 创建评论
		authAPI.DELETE("/comments/:id", controllers.DeleteComment)         // 删除自己评论

		// 用户信息
		user := authAPI.Group("/user")
		{
			user.GET("/profile", controllers.GetProfile)
			user.PUT("/profile", controllers.UpdateProfile)
		}

		// ===== 管理员 API =====
		admin := authAPI.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			// 管理员 - 用户管理
			admin.GET("/users", controllers.GetUserList)
			admin.PATCH("/users/:id/role", controllers.UpdateUserRole)
			admin.DELETE("/users/:id", controllers.DeleteUser)

			// 管理员 - 文章管理
			admin.POST("/articles", controllers.CreateArticle)       // 只有管理员能发文章
			admin.PUT("/articles/:id", controllers.UpdateArticle)    // 管理员编辑文章
			admin.DELETE("/articles/:id", controllers.DeleteArticle) // 管理员删除文章

			// 管理员 - 删除任意评论
			admin.DELETE("/comments/:id/force", controllers.ForceDeleteComment)

			// 分类管理
			admin.POST("/categories", controllers.CreateCategory)
			admin.DELETE("/categories/:id", controllers.DeleteCategory)
		}
	}

	return r
}
</file>

<file path="BackEnd/utils/utils.go">
package utils

import (
	"errors"
	"regexp"
	"strings"
	"time"

	"github.com/golang-jwt/jwt"
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(pwd string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
	return string(hash), err
}

func GenerateJWT(username string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"username": username,
		"exp":      time.Now().Add(time.Hour * 72).Unix(),
	})

	signedToken, err := token.SignedString([]byte("secret"))
	return "Bearer " + signedToken, err
}

func CheckPassword(password string, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func ParseJWT(tokenString string) (string, error) {
	if len(tokenString) > 7 && tokenString[:7] == "Bearer " {
		tokenString = tokenString[7:]
	}

	// 解析JWT
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected Signing Method")
		}
		return []byte("secret"), nil
	})

	if err != nil {
		return "", err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		username, ok := claims["username"].(string)
		if !ok {
			return "", errors.New("username claim is not a string")
		}
		return username, nil
	}
	return "", err
}

// ValidatePassword 校验密码复杂度
func ValidatePassword(pwd string) bool {
	pwd = strings.TrimSpace(pwd) // 去掉首尾空格
	if len(pwd) < 8 {
		return false
	}
	var (
		hasUpper = regexp.MustCompile(`[A-Z]`).MatchString
		hasLower = regexp.MustCompile(`[a-z]`).MatchString
		hasDigit = regexp.MustCompile(`\d`).MatchString
	)
	return hasUpper(pwd) && hasLower(pwd) && hasDigit(pwd)
}
</file>

<file path="BackEnd/.prettierrc.json">
{
  "printWidth": 200,
  "tabWidth": 2,
  "singleQuote": true,
  "semi": true,
  "trailingComma": "none",
  "vueIndentScriptAndStyle": true 
}
</file>

<file path="BackEnd/Dockerfile">
# 使用官方 Go 镜像
FROM golang:1.24-alpine

# 安装必要工具（可选）
RUN apk add --no-cache git bash

# 设置工作目录
WORKDIR /app

# 复制 Go Modules 文件并下载依赖
COPY go.mod go.sum ./
RUN go mod download

# 复制整个后端代码
COPY . .

# 编译 Go 程序
RUN go build -o server ./main.go

# 容器暴露端口
EXPOSE 3080

# 启动程序
CMD ["./server"]
</file>

<file path="BackEnd/go.mod">
module exchangeapp

go 1.24.0

toolchain go1.24.9

require (
	github.com/gin-gonic/gin v1.11.0
	github.com/golang-jwt/jwt v3.2.2+incompatible
	github.com/redis/go-redis/v9 v9.16.0
	github.com/spf13/viper v1.21.0
	golang.org/x/crypto v0.43.0
	gorm.io/driver/mysql v1.6.0
	gorm.io/gorm v1.31.1
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/bytedance/gopkg v0.1.3 // indirect
	github.com/bytedance/sonic v1.14.2 // indirect
	github.com/bytedance/sonic/loader v0.4.0 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudwego/base64x v0.1.6 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.11 // indirect
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.28.0 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/go-viper/mapstructure/v2 v2.4.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/goccy/go-yaml v1.18.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.55.0 // indirect
	github.com/sagikazarmark/locafero v0.11.0 // indirect
	github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/spf13/cast v1.10.0 // indirect
	github.com/spf13/pflag v1.0.10 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.1 // indirect
	go.uber.org/mock v0.6.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/arch v0.22.0 // indirect
	golang.org/x/mod v0.29.0 // indirect
	golang.org/x/net v0.46.0 // indirect
	golang.org/x/sync v0.17.0 // indirect
	golang.org/x/sys v0.37.0 // indirect
	golang.org/x/text v0.30.0 // indirect
	golang.org/x/tools v0.38.0 // indirect
	google.golang.org/protobuf v1.36.10 // indirect
)
</file>

<file path="BackEnd/main.go">
package main

import (
	"context"
	"exchangeapp/config"
	"exchangeapp/router"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"strings"
)

func main() {
	config.InitConfig()

	r := router.SetupRouter()

	// 确保端口号以冒号开头
	port := config.AppConfig.App.Port

	if port == "" {
		port = "8080"
	}
	if !strings.HasPrefix(port, ":") {
		port = ":" + port
	}

	srv := &http.Server{ // http服务器实例
		Addr:    port,
		Handler: r,
	}

	// 启动服务器并且进行监听
	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Listen: %s\n", err)
		}
	}()
	log.Printf("Server started on port %v", port)

	// 创建通道监听系统信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM) // 中断信号发送给quit
	<-quit                                             // 阻塞主 goroutine，直到收到信号，程序才会继续执行后面的退出逻辑

	log.Println("Shutting down server...") // 程序接收到中断信号后的处理

	// 创建 5 秒超时上下文，正常情况下等待正在处理的请求完成，如果超过 5 秒仍未完成，则强制关闭
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel() // 函数退出时释放上下文资源

	// 会停止接收新的请求
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %s", err)
	}

	log.Println("Server exiting")
}
</file>

<file path="BackEnd/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
config/
  config.go
  config.yml
  db.go
  redis.go
controllers/
  admin_controllers.go
  article_controllers.go
  auth_controllers.go
  exchange_rate_controllers.go
  like_controllers.go
global/
  global.go
middlewares/
  auth_middlewares.go
  role_middlewares.go
models/
  article.go
  exchange_rate.go
  user.go
router/
  router.go
utils/
  utils.go
.prettierrc.json
Dockerfile
go.mod
main.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/config.go">
package config

import (
	"log"

	"github.com/spf13/viper"
)

// 将配置文件赋值给自定义的结构体
type Config struct {
	App struct {
		Name string `yaml:"name"`
		Port string `yaml:"port"`
	} `yaml:"app"`
	Database struct {
		Dsn          string `yaml:"dsn"`
		MaxIdleCONNS int    `yaml:"MaxIdleCONNS"`
		MaxOpenCONNS int    `yaml:"MaxOpenCONNS"`
	}
	Redis struct {
		Addr     string `yaml:"addr"`
		Password string `yaml:"password"`
		DB       int    `yaml:"db"`
	} `yaml:"redis"`
}

var AppConfig *Config

func InitConfig() {
	viper.SetConfigName("config")
	viper.SetConfigType("yml")
	viper.AddConfigPath("./config")

	if err := viper.ReadInConfig(); err != nil {
		log.Fatalf("Error Reading Config file: %v", err)
	}

	AppConfig = &Config{}

	if err := viper.Unmarshal(AppConfig); err != nil {
		log.Fatalf("Unable to decode into struct: %v", err)
	}

	InitDB()
	InitRedis()
}
</file>

<file path="config/config.yml">
app:
  name: 'CurrencyExchangeApp'
  port: '3080'

database:
  dsn: 'root:123@tcp(mysql:3306)/exchangeApp?charset=utf8mb4&parseTime=True&loc=Local'
  MaxIdleCONNS: 10
  MaxOpenCONNS: 100

redis:
  addr: 'redis:6379'
  password: ''
  db: 0
</file>

<file path="config/db.go">
package config

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"fmt"
	"log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func InitDB() {
	dsn := AppConfig.Database.Dsn
	fmt.Println("DSN:", dsn)
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("Failed to initialize database, got error: %v", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		log.Fatalf("Failed to configure database, got error: %v", err)
	}

	sqlDB.SetMaxIdleConns(AppConfig.Database.MaxIdleCONNS)
	sqlDB.SetMaxOpenConns(AppConfig.Database.MaxOpenCONNS)
	sqlDB.SetConnMaxLifetime(time.Hour)

	global.Db = db

	// 迁移模型
	if err := global.Db.AutoMigrate(
		&models.User{},
		&models.Article{},
		&models.ExchangeRate{},
	); err != nil {
		log.Fatalf("Failed to migrate database, got error: %v", err)
	}

	fmt.Println("Database initialized and migrated successfully")
}
</file>

<file path="config/redis.go">
package config

import (
	"context"
	"exchangeapp/global"
	"log"

	"github.com/redis/go-redis/v9"
)

func InitRedis() {
	ctx := context.Background()
	RedisClient := redis.NewClient(&redis.Options{
		Addr:     AppConfig.Redis.Addr,
		Password: AppConfig.Redis.Password,
		DB:       AppConfig.Redis.DB,
	})

	_, err := RedisClient.Ping(ctx).Result()

	if err != nil {
		log.Fatalf("Failed to connect to Redis,got error: %v", err)
	}

	global.RedisDB = RedisClient
}
</file>

<file path="controllers/admin_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"

	"github.com/gin-gonic/gin"
)

// GetUserList 获取所有用户列表 (仅管理员)
func GetUserList(ctx *gin.Context) {
	var users []models.User
	// 查询所有用户，排除密码字段
	// Select 语法取决于 GORM 版本，这里使用简单查询后手动清空密码，或者使用 Smart Select
	if err := global.Db.Find(&users).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 处于安全考虑，清空密码和敏感信息
	var safeUsers []map[string]interface{}
	for _, u := range users {
		safeUsers = append(safeUsers, map[string]interface{}{
			"ID":        u.ID,
			"username":  u.Username,
			"nickname":  u.Nickname,
			"email":     u.Email,
			"role":      u.Role,
			"avatar":    u.Avatar,
			"CreatedAt": u.CreatedAt,
		})
	}

	ctx.JSON(http.StatusOK, safeUsers)
}

// UpdateUserRole 修改用户角色 (仅管理员)
func UpdateUserRole(ctx *gin.Context) {
	// 1. 获取目标用户 ID
	targetUserID := ctx.Param("id")

	// 2. 获取请求体中的新角色
	var input struct {
		Role string `json:"role" binding:"required"` // 只允许 "admin" 或 "user"
	}
	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 简单校验角色合法性
	if input.Role != "admin" && input.Role != "user" {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role value"})
		return
	}

	// 3. 查找并更新用户
	var user models.User
	if err := global.Db.First(&user, targetUserID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// 防止自我降级 (可选：防止管理员不小心把自己改成 user 后失去权限)
	currentUsername := ctx.GetString("username")
	if user.Username == currentUsername && input.Role == "user" {
		ctx.JSON(http.StatusForbidden, gin.H{"error": "You cannot demote yourself"})
		return
	}

	// 更新数据库
	if err := global.Db.Model(&user).Update("role", input.Role).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"message":  "Role updated successfully",
		"user_id":  user.ID,
		"new_role": input.Role,
	})
}

// DeleteUser 删除用户 (仅管理员)
func DeleteUser(ctx *gin.Context) {
	// 目标用户 ID（要删除谁）
	targetID := ctx.Param("id")

	// 当前正在操作的管理员 ID（从 Token 获取）
	currentUserID := ctx.GetString("userID")

	// 防止删除自己
	if currentUserID == targetID {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": "不能删除自己的账号",
		})
		return
	}

	// 检查用户是否存在
	var user models.User
	if err := global.Db.First(&user, targetID).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
		return
	}

	// 删除用户
	if err := global.Db.Delete(&models.User{}, targetID).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}
</file>

<file path="controllers/article_controllers.go">
package controllers

import (
	"encoding/json"
	"errors"
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
)

var cacheKey = "articles"

func CreateArticle(ctx *gin.Context) {
	var article models.Article

	if err := ctx.ShouldBindJSON(&article); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	if err := global.Db.Create(&article).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	// 在新增文章以后，删除旧缓存，让下次读取时强制从数据库刷新数据
	if err := global.RedisDB.Del(ctx.Request.Context(), cacheKey).Err(); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusCreated, article)
}

func GetArticles(ctx *gin.Context) {
	cachedData, err := global.RedisDB.Get(ctx.Request.Context(), cacheKey).Result()

	// 未命中缓存
	if err == redis.Nil {
		var articles []models.Article

		// 查询数据库
		if err := global.Db.Find(&articles).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				ctx.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
			} else {
				ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			}
			return
		}

		// 将文章序列号为json
		articleJSON, err := json.Marshal(articles)
		if err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		// 写入缓存
		if err := global.RedisDB.Set(ctx.Request.Context(), cacheKey, articleJSON, 10*time.Minute).Err(); err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		ctx.JSON(http.StatusOK, articles) // 返回客户端
		return
	}

	// 其他 Redis 错误
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// 命中缓存
	var articles []models.Article
	if err := json.Unmarshal([]byte(cachedData), &articles); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(http.StatusOK, articles)
}

func GetArticleByID(ctx *gin.Context) {
	// 获取路径的参数
	id := ctx.Param("id")

	var article models.Article

	if err := global.Db.Where("id = ?", id).First(&article).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) { // 错误匹配
			ctx.JSON(http.StatusNotFound, gin.H{
				"error": err.Error(),
			})
		} else {
			ctx.JSON(http.StatusInternalServerError, gin.H{
				"error": err.Error(),
			})
		}
		return
	}

	ctx.JSON(http.StatusOK, article)
}
</file>

<file path="controllers/auth_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"exchangeapp/utils"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func Register(ctx *gin.Context) {
	var input struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
		Role     string `json:"role"` // 可选
		Nickname string `json:"nickname"`
		Email    string `json:"email" binding:"email"`
		Avatar   string `json:"avatar"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 验证角色合法性
	if input.Role != "" && input.Role != "admin" && input.Role != "user" {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role value"})
		return
	}

	if !utils.ValidatePassword(input.Password) {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": "密码至少8位，必须包含大写字母、小写字母和数字",
		})
		return
	}

	hashedPwd, err := utils.HashPassword(input.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user := models.User{
		Username: input.Username,
		Password: hashedPwd,
		Role:     input.Role,
		Nickname: input.Nickname,
		Email:    input.Email,
		Avatar:   input.Avatar,
	}

	if user.Role == "" {
		user.Role = "user"
	}

	// 检查用户名和邮箱是否已存在
	var existingUser models.User
	if err := global.Db.Where("username = ? OR email = ?", user.Username, user.Email).First(&existingUser).Error; err == nil {
		if existingUser.Username == user.Username {
			ctx.JSON(http.StatusBadRequest, gin.H{"error": "用户名已存在"})
		} else {
			ctx.JSON(http.StatusBadRequest, gin.H{"error": "邮箱已存在"})
		}
		return
	}

	if err := global.Db.Create(&user).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	token, err := utils.GenerateJWT(user.Username)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user.Password = "" // 不返回密码
	ctx.JSON(http.StatusOK, gin.H{"token": token, "user": user})
}

func Login(ctx *gin.Context) {
	// 登录过程的用户名和密码
	var input struct {
		Username string `json:"username"` // 结构体标签(方便将json字段映射到结构体)
		Password string `json:"password"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	var user models.User

	// 验证用户名
	if err := global.Db.Where("username = ?", input.Username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusUnauthorized, gin.H{
			"error": "wrong credentials",
		})
		return
	}

	key := "login_fail:" + input.Username
	failCount, _ := global.RedisDB.Get(ctx, key).Int()
	if failCount >= 5 {
		ctx.JSON(http.StatusForbidden, gin.H{"error": "尝试次数过多，请15分钟后再试"})
		return
	}

	if !utils.CheckPassword(input.Password, user.Password) {
		// 登录失败时
		global.RedisDB.Incr(ctx, key)
		global.RedisDB.Expire(ctx, key, time.Minute*15)
		ctx.JSON(http.StatusUnauthorized, gin.H{
			"error": "wrong credentials",
		})
		return
	}

	// 登录成功，删除失败计数
	global.RedisDB.Del(ctx, key)

	token, err := utils.GenerateJWT(user.Username)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"token": token})
}

// 新增获取/更新用户信息接口
func GetProfile(ctx *gin.Context) {
	username := ctx.GetString("username")
	var user models.User
	if err := global.Db.Where("username = ?", username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
		return
	}
	user.Password = "" // 不返回密码
	ctx.JSON(http.StatusOK, user)
}

func UpdateProfile(ctx *gin.Context) {
	username := ctx.GetString("username")

	var input struct {
		Nickname string `json:"nickname"`
		Email    string `json:"email" binding:"email"`
		Avatar   string `json:"avatar"`
		Password string `json:"password"`
	}

	if err := ctx.ShouldBindJSON(&input); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var user models.User
	if err := global.Db.Where("username = ?", username).First(&user).Error; err != nil {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
		return
	}

	if input.Nickname != "" {
		user.Nickname = input.Nickname
	}

	if input.Email != "" {
		user.Email = input.Email
	}

	if input.Avatar != "" {
		user.Avatar = input.Avatar
	}

	if input.Password != "" {
		// 校验密码强度
		if !utils.ValidatePassword(input.Password) {
			ctx.JSON(http.StatusBadRequest, gin.H{
				"error": "密码至少8位，必须包含大写字母、小写字母和数字",
			})
			return
		}

		hashedPwd, err := utils.HashPassword(input.Password)
		if err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		user.Password = hashedPwd
	}

	if err := global.Db.Save(&user).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	user.Password = ""
	ctx.JSON(http.StatusOK, user)
}
</file>

<file path="controllers/exchange_rate_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func CreateExchangeRate(ctx *gin.Context) {
	var exchangeRate models.ExchangeRate

	if err := ctx.ShouldBindJSON(&exchangeRate); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	exchangeRate.Date = time.Now()

	if err := global.Db.Create(&exchangeRate).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"message": "汇率创建成功",
		"data":    exchangeRate,
	})
}

func GetExchangeRates(ctx *gin.Context) {
	var exchangeRates []models.ExchangeRate

	if err := global.Db.Find(&exchangeRates).Error; err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}
	ctx.JSON(http.StatusOK, exchangeRates)
}
</file>

<file path="controllers/like_controllers.go">
package controllers

import (
	"exchangeapp/global"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/redis/go-redis/v9"
)

func LikeArticle(ctx *gin.Context) {
	articleID := ctx.Param("id")

	likeKey := "article:" + articleID + ":likes"

	// 获取点赞后的数量
	likes, err := global.RedisDB.Incr(ctx.Request.Context(), likeKey).Result()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"message": "Successfully Liked",
		"likes":   likes, // 返回点赞数量保持一致性
	})
}

func GetArticleLikes(ctx *gin.Context) {
	articleID := ctx.Param("id")

	likeKey := "article:" + articleID + ":likes"

	likes, err := global.RedisDB.Get(ctx.Request.Context(), likeKey).Result()

	if err == redis.Nil { // key不存在
		likes = "0"
	} else if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"likes": likes,
	})
}
</file>

<file path="global/global.go">
package global

import (
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
)

// 全局变量
var (
	Db      *gorm.DB
	RedisDB *redis.Client
)
</file>

<file path="middlewares/auth_middlewares.go">
package middlewares

import (
	"exchangeapp/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

// 验证JWT是否有效

func AuthMiddleWare() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		token := ctx.GetHeader("Authorization")
		if token == "" {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"error": "Authorization header is required",
			})
			ctx.Abort() // 阻止后续的中间件和处理函数执行,但不会中断当前函数中 ctx.Abort()之后的代码执行
			return
		}
		username, err := utils.ParseJWT(token)

		if err != nil {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid token: " + err.Error(),
			})
			ctx.Abort()
			return
		}

		ctx.Set("username", username) // 用于在不同中间件传递kv数据
		ctx.Next()

	}
}
</file>

<file path="middlewares/role_middlewares.go">
package middlewares

import (
	"exchangeapp/global"
	"exchangeapp/models"
	"net/http"

	"github.com/gin-gonic/gin"
)

// 检查角色
func AdminMiddleware() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		username, exists := ctx.Get("username")
		if !exists {
			ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			ctx.Abort()
			return
		}
		var user models.User
		if err := global.Db.Where("username = ?", username.(string)).First(&user).Error; err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": "User not found"})
			ctx.Abort()
			return
		}
		if user.Role != "admin" {
			ctx.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			ctx.Abort()
			return
		}
		ctx.Next()
	}
}
</file>

<file path="models/article.go">
package models

import "gorm.io/gorm"

// 在mysql表格中都会变为小写
type Article struct {
	gorm.Model
	Title   string `binding:"required"`
	Content string `binding:"required"`
	Preview string `binding:"required"` // 文字的预览
	Likes   int    `gorm:"default:0"`
}
</file>

<file path="models/exchange_rate.go">
package models

import "time"

type ExchangeRate struct {
	ID           uint      `gorm:"primaryKey" json:"id"`
	FromCurrency string    `json:"fromCurrency" binding:"required"`
	ToCurrency   string    `json:"toCurrency" binding:"required"`
	Rate         float64   `json:"rate" binding:"required"`
	Date         time.Time `json:"date"`
}
</file>

<file path="models/user.go">
package models

import "gorm.io/gorm"

type User struct {
	gorm.Model
	Username string `gorm:"unique" json:"username" binding:"required"`
	Password string `json:"-" binding:"required"`
	Role     string `gorm:"default:'user'" json:"role"` // user/admin
	Nickname string `json:"nickname"`                   // 昵称
	Email    string `gorm:"unique" json:"email"`        // 可为空，不强制验证
	Avatar   string `json:"avatar"`                     // 头像
}

/*Role 默认是普通用户 user，管理员为 admin

Password 不在 JSON 输出中显示（json:"-"）

Nickname, Email, Avatar 可以为空 */
</file>

<file path="router/router.go">
package router

import (
	"exchangeapp/controllers"
	"exchangeapp/middlewares"
	"time"

	"github.com/gin-contrib/cors"

	"github.com/gin-gonic/gin"
)

func SetupRouter() *gin.Engine {
	r := gin.Default()

	// 允许跨域请求
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:5173", "http://127.0.0.1:5173"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"}, // 添加 PATCH
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	// 用户注册与登录
	auth := r.Group("/api/auth")
	{
		auth.POST("/login", controllers.Login)
		auth.POST("/register", controllers.Register)
	}

	api := r.Group("/api")
	{
		// 不需要认证的公共接口
		api.GET("/exchangeRates", controllers.GetExchangeRates)

		// 需要认证的接口组
		authenticated := api.Group("")
		authenticated.Use(middlewares.AuthMiddleWare())
		{
			authenticated.POST("/exchangeRates", controllers.CreateExchangeRate)
			authenticated.POST("/articles", controllers.CreateArticle)
			authenticated.GET("/articles", controllers.GetArticles)
			authenticated.GET("/articles/:id", controllers.GetArticleByID)
			authenticated.POST("/articles/:id/like", controllers.LikeArticle)
			authenticated.GET("/articles/:id/like", controllers.GetArticleLikes)

			// 用户信息接口
			user := authenticated.Group("/user")
			{
				user.GET("/profile", controllers.GetProfile)
				user.PUT("/profile", controllers.UpdateProfile)
			}

			// 管理员专用接口组
			adminGroup := authenticated.Group("/admin")
			adminGroup.Use(middlewares.AdminMiddleware())
			{
				adminGroup.GET("/users", controllers.GetUserList)
				adminGroup.PATCH("/users/:id/role", controllers.UpdateUserRole)
				adminGroup.DELETE("/users/:id", controllers.DeleteUser)
			}
		}
	}

	return r
}
</file>

<file path="utils/utils.go">
package utils

import (
	"errors"
	"regexp"
	"strings"
	"time"

	"github.com/golang-jwt/jwt"
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(pwd string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
	return string(hash), err
}

func GenerateJWT(username string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"username": username,
		"exp":      time.Now().Add(time.Hour * 72).Unix(),
	})

	signedToken, err := token.SignedString([]byte("secret"))
	return "Bearer " + signedToken, err
}

func CheckPassword(password string, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func ParseJWT(tokenString string) (string, error) {
	if len(tokenString) > 7 && tokenString[:7] == "Bearer " {
		tokenString = tokenString[7:]
	}

	// 解析JWT
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected Signing Method")
		}
		return []byte("secret"), nil
	})

	if err != nil {
		return "", err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		username, ok := claims["username"].(string)
		if !ok {
			return "", errors.New("username claim is not a string")
		}
		return username, nil
	}
	return "", err
}

// ValidatePassword 校验密码复杂度
func ValidatePassword(pwd string) bool {
	pwd = strings.TrimSpace(pwd) // 去掉首尾空格
	if len(pwd) < 8 {
		return false
	}
	var (
		hasUpper = regexp.MustCompile(`[A-Z]`).MatchString
		hasLower = regexp.MustCompile(`[a-z]`).MatchString
		hasDigit = regexp.MustCompile(`\d`).MatchString
	)
	return hasUpper(pwd) && hasLower(pwd) && hasDigit(pwd)
}
</file>

<file path=".prettierrc.json">
{
  "printWidth": 200,
  "tabWidth": 2,
  "singleQuote": true,
  "semi": true,
  "trailingComma": "none",
  "vueIndentScriptAndStyle": true 
}
</file>

<file path="Dockerfile">
# 使用官方 Go 镜像
FROM golang:1.24-alpine

# 安装必要工具（可选）
RUN apk add --no-cache git bash

# 设置工作目录
WORKDIR /app

# 复制 Go Modules 文件并下载依赖
COPY go.mod go.sum ./
RUN go mod download

# 复制整个后端代码
COPY . .

# 编译 Go 程序
RUN go build -o server ./main.go

# 容器暴露端口
EXPOSE 3080

# 启动程序
CMD ["./server"]
</file>

<file path="go.mod">
module exchangeapp

go 1.24.0

toolchain go1.24.9

require (
	github.com/gin-gonic/gin v1.11.0
	github.com/golang-jwt/jwt v3.2.2+incompatible
	github.com/redis/go-redis/v9 v9.16.0
	github.com/spf13/viper v1.21.0
	golang.org/x/crypto v0.43.0
	gorm.io/driver/mysql v1.6.0
	gorm.io/gorm v1.31.1
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/bytedance/gopkg v0.1.3 // indirect
	github.com/bytedance/sonic v1.14.2 // indirect
	github.com/bytedance/sonic/loader v0.4.0 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudwego/base64x v0.1.6 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.11 // indirect
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.28.0 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/go-viper/mapstructure/v2 v2.4.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/goccy/go-yaml v1.18.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.55.0 // indirect
	github.com/sagikazarmark/locafero v0.11.0 // indirect
	github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/spf13/cast v1.10.0 // indirect
	github.com/spf13/pflag v1.0.10 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.1 // indirect
	go.uber.org/mock v0.6.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/arch v0.22.0 // indirect
	golang.org/x/mod v0.29.0 // indirect
	golang.org/x/net v0.46.0 // indirect
	golang.org/x/sync v0.17.0 // indirect
	golang.org/x/sys v0.37.0 // indirect
	golang.org/x/text v0.30.0 // indirect
	golang.org/x/tools v0.38.0 // indirect
	google.golang.org/protobuf v1.36.10 // indirect
)
</file>

<file path="main.go">
package main

import (
	"context"
	"exchangeapp/config"
	"exchangeapp/router"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"strings"
)

func main() {
	config.InitConfig()

	r := router.SetupRouter()

	// 确保端口号以冒号开头
	port := config.AppConfig.App.Port

	if port == "" {
		port = "8080"
	}
	if !strings.HasPrefix(port, ":") {
		port = ":" + port
	}

	srv := &http.Server{ // http服务器实例
		Addr:    port,
		Handler: r,
	}

	// 启动服务器并且进行监听
	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Listen: %s\n", err)
		}
	}()
	log.Printf("Server started on port %v", port)

	// 创建通道监听系统信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM) // 中断信号发送给quit
	<-quit                                             // 阻塞主 goroutine，直到收到信号，程序才会继续执行后面的退出逻辑

	log.Println("Shutting down server...") // 程序接收到中断信号后的处理

	// 创建 5 秒超时上下文，正常情况下等待正在处理的请求完成，如果超过 5 秒仍未完成，则强制关闭
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel() // 函数退出时释放上下文资源

	// 会停止接收新的请求
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %s", err)
	}

	log.Println("Server exiting")
}
</file>

</files>
</file>

<file path="FrontEnd/src/components/Login.vue">
<template>  
  <div class="auth-container">  
    <el-form :model="form" class="auth-form" label-position="top" @submit.prevent="login">  
      <h2 style="text-align: center; margin-bottom: 20px;">用户登录</h2>
      <el-form-item label="用户名">  
        <el-input v-model="form.username" placeholder="请输入用户名" />  
      </el-form-item>  
      <el-form-item label="密码">  
        <el-input v-model="form.password" type="password" placeholder="请输入密码" show-password />  
      </el-form-item>  
      <el-form-item>  
        <el-button type="primary" native-type="submit" style="width: 100%" :loading="loading">登录</el-button>  
      </el-form-item>  
    </el-form>  
  </div>  
</template>  
  
<script setup lang="ts">
import { ElMessage } from 'element-plus';
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '../store/auth';

const form = ref({
  username: '',
  password: '',
});

const loading = ref(false);
const authStore = useAuthStore();
const router = useRouter();

const login = async () => {
  loading.value = true;
  try {
    await authStore.login(form.value.username, form.value.password);
    ElMessage.success('登录成功');
    router.push({ name: 'News' });
  } catch (error: any) {
    // 这里的 error.message 已经是 store 中处理过的后端 error 字段
    ElMessage.error(error.message || '登录失败，请检查网络或重试。');
  } finally {
    loading.value = false;
  }
};
</script>
  
<style scoped>
.auth-container {  
  display: flex;  
  justify-content: center;  
  align-items: center;  
  height: 80vh; 
  background-color: #f5f5f5; 
  padding: 20px;  
  box-sizing: border-box; 
}  
  
.auth-form {  
  width: 100%;  
  max-width: 360px; 
  padding: 30px;  
  background-color: #fff;  
  border-radius: 8px;  
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);  
}  
</style>
</file>

<file path="FrontEnd/src/components/Register.vue">
<template>
  <div class="auth-container">
    <el-form :model="form" class="auth-form" label-position="top" @submit.prevent="register">
      <h2 style="text-align: center; margin-bottom: 20px;">用户注册</h2>
      
      <el-form-item label="用户名 (必填)" required>
        <el-input v-model="form.username" placeholder="唯一用户名" />
      </el-form-item>
      
      <el-form-item label="密码 (必填)" required>
        <el-input v-model="form.password" type="password" placeholder="8位以上，含大小写字母和数字" show-password />
      </el-form-item>

      <el-form-item label="昵称">
        <el-input v-model="form.nickname" placeholder="您的昵称" />
      </el-form-item>

      <el-form-item label="邮箱">
        <el-input v-model="form.email" placeholder="example@email.com" />
      </el-form-item>

      <el-form-item label="头像 URL">
        <el-input v-model="form.avatar" placeholder="https://example.com/avatar.png" />
      </el-form-item>

      <el-button type="primary" native-type="submit" style="width: 100%" :loading="loading">注册</el-button>
    </el-form>
  </div>
</template>

<script setup lang="ts">
import { ElMessage } from 'element-plus';
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '../store/auth';

const form = ref({
  username: '',
  password: '',
  nickname: '',
  email: '',
  avatar: ''
});

const loading = ref(false);
const authStore = useAuthStore();
const router = useRouter();

const register = async () => {
  if (!form.value.username || !form.value.password) {
    ElMessage.warning('用户名和密码是必填项');
    return;
  }

  loading.value = true;
  try {
    await authStore.register({
      username: form.value.username,
      password: form.value.password,
      nickname: form.value.nickname || undefined,
      email: form.value.email || undefined,
      avatar: form.value.avatar || undefined
    });
    ElMessage.success('注册成功！');
    router.push({ name: 'News' });
  } catch (error: any) {
    ElMessage.error(error.message || '注册失败，请重试。');
  } finally {
    loading.value = false;
  }
};
</script>

<style scoped>
.auth-container {  
  display: flex;  
  justify-content: center;  
  align-items: center;  
  min-height: 80vh; 
  background-color: #f5f5f5; 
  padding: 20px;  
  box-sizing: border-box; 
}  
  
.auth-form {  
  width: 100%;  
  max-width: 400px; 
  padding: 30px;  
  background-color: #fff;  
  border-radius: 8px;  
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);  
}  
</style>
</file>

<file path="FrontEnd/src/router/index.ts">
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import Login from '../components/Login.vue';
import Register from '../components/Register.vue';
import { useAuthStore } from '../store/auth';
import AdminUserView from '../views/AdminUserView.vue';
import CurrencyExchangeView from '../views/CurrencyExchangeView.vue';
import HomeView from '../views/HomeView.vue';
import NewsDetailView from '../views/NewsDetailView.vue';
import NewsView from '../views/NewsView.vue';
import ProfileView from '../views/ProfileView.vue';

const routes: RouteRecordRaw[] = [
  { path: '/', name: 'Home', component: HomeView },
  { path: '/exchange', name: 'CurrencyExchange', component: CurrencyExchangeView },
  { path: '/news', name: 'News', component: NewsView },
  { path: '/news/:id', name: 'NewsDetail', component: NewsDetailView },
  { path: '/login', name: 'Login', component: Login },
  { path: '/register', name: 'Register', component: Register },
  { path: '/profile', name: 'Profile', component: ProfileView, meta: { requiresAuth: true } },
  { 
    path: '/admin/users', 
    name: 'AdminUsers', 
    component: AdminUserView, 
    meta: { requiresAuth: true, requiresAdmin: true } 
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// 路由守卫 - 认证检查和管理员权限检查
// FrontEnd/src/router/index.ts
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore();
  
  // 检查是否需要登录
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login');
    return;
  }
  
  // 检查是否需要管理员权限
  if (to.meta.requiresAdmin) {
    if (!authStore.isAuthenticated) {
      next('/login');
      return;
    }
    
    // 确保用户信息已加载
    if (!authStore.user) {
      try {
        await authStore.fetchProfile();
      } catch (error) {
        next('/login');
        return;
      }
    }
    
    // 检查管理员权限
    if (authStore.user?.role !== 'admin') {
      next('/');
      return;
    }
  }
  
  next();
});

function checkAdminPermission(to: any, next: any) {
  const authStore = useAuthStore();
  if (authStore.user?.role !== 'admin') {
    next('/');
    return;
  }
  next();
}

export default router;
</file>

<file path="FrontEnd/src/store/auth.ts">
// FrontEnd/src/store/auth.ts
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import axios from '../axios';

// 定义用户信息接口
export interface User {
  ID: number;
  username: string;
  role: string;
  nickname: string;
  email: string;
  avatar: string;
  CreatedAt?: string;
  UpdatedAt?: string;
}

// 注册所需参数接口
export interface RegisterPayload {
  username: string;
  password: string;
  nickname?: string;
  email?: string;
  avatar?: string;
}

// 更新信息参数接口
export interface UpdateProfilePayload {
  nickname?: string;
  email?: string;
  avatar?: string;
  password?: string;
}

export const useAuthStore = defineStore('auth', () => {
  const token = ref<string | null>(localStorage.getItem('token'));
  const user = ref<User | null>(null);

  const isAuthenticated = computed(() => !!token.value);

  // 获取当前用户信息
  const fetchProfile = async () => {
    if (!token.value) return;
    try {
      const response = await axios.get<User>('/user/profile');
      user.value = response.data;
    } catch (error) {
      console.error('Failed to fetch profile', error);
      // 如果获取用户信息失败（如token过期），可能需要登出
      // logout(); 
    }
  };

  // 登录
  const login = async (username: string, password: string) => {
    try {
      const response = await axios.post('/auth/login', { username, password });
      token.value = response.data.token;
      localStorage.setItem('token', token.value || '');
      
      // 登录成功后立即获取用户信息
      await fetchProfile();
    } catch (error: any) {
      // 透传后端具体的错误信息
      if (error.response && error.response.data && error.response.data.error) {
        throw new Error(error.response.data.error);
      }
      throw error;
    }
  };

  // 注册
  const register = async (payload: RegisterPayload) => {
    try {
      // 这里的 payload 包含了 username, password, nickname, email, avatar
      const response = await axios.post('/auth/register', payload);
      
      token.value = response.data.token;
      // 注册接口直接返回了 user 对象，直接保存，省去一次请求
      if (response.data.user) {
        user.value = response.data.user;
      }
      localStorage.setItem('token', token.value || '');
    } catch (error: any) {
      if (error.response && error.response.data && error.response.data.error) {
        throw new Error(error.response.data.error);
      }
      throw error;
    }
  };

  // 更新用户信息
  const updateProfile = async (payload: UpdateProfilePayload) => {
    try {
      const response = await axios.put<User>('/user/profile', payload);
      // 更新本地状态
      user.value = response.data;
      return response.data;
    } catch (error: any) {
      if (error.response && error.response.data && error.response.data.error) {
        throw new Error(error.response.data.error);
      }
      throw error;
    }
  }

  const logout = () => {
    token.value = null;
    user.value = null;
    localStorage.removeItem('token');
  };

 const checkAdminPermission = async (): Promise<boolean> => {
  if (!user.value) {
    await fetchProfile();
  }
  return user.value?.role === 'admin';
};

// 在 return 语句中添加这个方法
return {
  token,
  user,
  isAuthenticated,
  login,
  register,
  fetchProfile,
  updateProfile,
  logout,
  checkAdminPermission // 新增方法
};
});
</file>

<file path="FrontEnd/src/types/Article.d.ts">
export interface Article {
    ID: string;
    Title: string;
    Preview: string;
    Content: string;
}

export interface Like {
    likes: number;
}
</file>

<file path="FrontEnd/src/types/User.d.ts">
export interface User {
  ID: number; // 确保与后端 uint 类型兼容
  username: string;
  nickname: string;
  email: string;
  role: string;
  avatar: string;
  CreatedAt: string;
  UpdatedAt?: string;
}

export interface AdminUserListResponse {
  users: User[];
  total: number;
}

export interface ChangeRoleRequest {
  role: 'admin' | 'user';
}

export interface ChangeRoleResponse {
  message: string;
  user_id: number;
  new_role: string;
}
</file>

<file path="FrontEnd/src/views/AdminUserView.vue">
<template>
  <el-container class="admin-container">
    <el-card class="admin-card">
      <template #header>
        <div class="card-header">
          <h2>用户管理</h2>
          <el-button type="primary" @click="refreshUsers">刷新</el-button>
        </div>
      </template>

      <el-table :data="users" v-loading="loading" style="width: 100%">
        <el-table-column prop="ID" label="ID" width="80" />
        <el-table-column prop="username" label="用户名" width="120" />
        <el-table-column prop="nickname" label="昵称" width="120" />
        <el-table-column prop="email" label="邮箱" width="200" />
        <el-table-column prop="role" label="角色" width="100">
          <template #default="scope">
            <el-tag :type="scope.row.role === 'admin' ? 'danger' : 'primary'">
              {{ scope.row.role === 'admin' ? '管理员' : '普通用户' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="CreatedAt" label="注册时间" width="180">
          <template #default="scope">
            {{ formatDate(scope.row.CreatedAt) }}
          </template>
        </el-table-column>
        <el-table-column label="操作" width="200">
          <template #default="scope">
            <el-button 
              size="small" 
              :type="scope.row.role === 'admin' ? 'warning' : 'success'"
              @click="handleChangeRole(scope.row)"
              :disabled="scope.row.username === authStore.user?.username"
            >
              {{ scope.row.role === 'admin' ? '降为用户' : '设为管理员' }}
            </el-button>
            <el-button 
              size="small" 
              type="danger" 
              @click="handleDeleteUser(scope.row)"
              :disabled="scope.row.username === authStore.user?.username"
            >
              删除
            </el-button>
          </template>
        </el-table-column>
      </el-table>

      <div class="pagination-container">
        <el-pagination
          v-model:current-page="currentPage"
          v-model:page-size="pageSize"
          :page-sizes="[10, 20, 50, 100]"
          :total="total"
          layout="total, sizes, prev, pager, next, jumper"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </div>
    </el-card>

    <!-- 修改角色确认对话框 -->
    <el-dialog
      v-model="roleDialogVisible"
      title="修改用户角色"
      width="400px"
    >
      <p>确定要将用户 <strong>{{ selectedUser?.username }}</strong> 的角色修改为 <strong>{{ selectedUser?.role === 'admin' ? '普通用户' : '管理员' }}</strong> 吗？</p>
      <template #footer>
        <el-button @click="roleDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="confirmChangeRole" :loading="roleLoading">
          确认修改
        </el-button>
      </template>
    </el-dialog>

    <!-- 删除用户确认对话框 -->
    <el-dialog
      v-model="deleteDialogVisible"
      title="删除用户"
      width="400px"
    >
      <p style="color: #f56c6c;">警告：此操作将永久删除用户 <strong>{{ selectedUser?.username }}</strong>，且无法恢复！</p>
      <template #footer>
        <el-button @click="deleteDialogVisible = false">取消</el-button>
        <el-button type="danger" @click="confirmDeleteUser" :loading="deleteLoading">
          确认删除
        </el-button>
      </template>
    </el-dialog>
  </el-container>
</template>

<script setup lang="ts">
import { ElMessage } from 'element-plus';
import { computed, onMounted, ref } from 'vue';
import axios from '../axios';
import { useAuthStore } from '../store/auth';

interface User {
  ID: number;
  username: string;
  nickname: string;
  email: string;
  role: string;
  avatar: string;
  CreatedAt: string;
}

const authStore = useAuthStore();
const loading = ref(false);
const users = ref<User[]>([]);
const total = ref(0);
const currentPage = ref(1);
const pageSize = ref(10);

// 对话框相关
const roleDialogVisible = ref(false);
const deleteDialogVisible = ref(false);
const selectedUser = ref<User | null>(null);
const roleLoading = ref(false);
const deleteLoading = ref(false);

// 获取用户列表
const fetchUsers = async () => {
  loading.value = true;
  try {
    const response = await axios.get('/admin/users');
    users.value = response.data;
    total.value = response.data.length;
  } catch (error: any) {
    ElMessage.error('获取用户列表失败: ' + (error.response?.data?.error || error.message));
  } finally {
    loading.value = false;
  }
};

// 刷新用户列表
const refreshUsers = () => {
  currentPage.value = 1;
  fetchUsers();
};

// 修改角色
const handleChangeRole = (user: User) => {
  selectedUser.value = user;
  roleDialogVisible.value = true;
};

const confirmChangeRole = async () => {
  if (!selectedUser.value) return;
  
  roleLoading.value = true;
  try {
    const newRole = selectedUser.value.role === 'admin' ? 'user' : 'admin';
    await axios.patch(`/admin/users/${selectedUser.value.ID}/role`, {
      role: newRole
    });
    
    ElMessage.success('角色修改成功');
    roleDialogVisible.value = false;
    await fetchUsers(); // 刷新列表
  } catch (error: any) {
    ElMessage.error('修改角色失败: ' + (error.response?.data?.error || error.message));
  } finally {
    roleLoading.value = false;
  }
};

// 删除用户
const handleDeleteUser = (user: User) => {
  selectedUser.value = user;
  deleteDialogVisible.value = true;
};

const confirmDeleteUser = async () => {
  if (!selectedUser.value) return;
  
  deleteLoading.value = true;
  try {
    await axios.delete(`/admin/users/${selectedUser.value.ID}`);
    
    ElMessage.success('用户删除成功');
    deleteDialogVisible.value = false;
    await fetchUsers(); // 刷新列表
  } catch (error: any) {
    ElMessage.error('删除用户失败: ' + (error.response?.data?.error || error.message));
  } finally {
    deleteLoading.value = false;
  }
};

// 分页处理
const handleSizeChange = (newSize: number) => {
  pageSize.value = newSize;
  currentPage.value = 1;
  // 这里可以添加分页请求逻辑
};

const handleCurrentChange = (newPage: number) => {
  currentPage.value = newPage;
  // 这里可以添加分页请求逻辑
};

// 日期格式化
const formatDate = (dateString: string) => {
  if (!dateString) return '';
  return new Date(dateString).toLocaleString('zh-CN');
};

// 计算分页后的数据（前端分页，如果数据量大建议后端分页）
const paginatedUsers = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return users.value.slice(start, end);
});

onMounted(() => {
  fetchUsers();
});
</script>

<style scoped>
.admin-container {
  padding: 20px;
  min-height: calc(100vh - 60px);
  background-color: #f5f7fa;
}

.admin-card {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.pagination-container {
  margin-top: 20px;
  display: flex;
  justify-content: center;
}

.avatar-cell {
  display: flex;
  align-items: center;
}

.avatar-image {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  margin-right: 8px;
}
</style>
</file>

<file path="FrontEnd/src/views/CurrencyExchangeView.vue">
<template>  
  <el-container>  
    <el-form :model="form" class="exchange-form">  
      <el-form-item label="从货币" label-width="80px">  
        <el-select v-model="form.fromCurrency" placeholder="选择货币">  
          <el-option v-for="currency in currencies" :key="currency" :label="currency" :value="currency" />  
        </el-select>  
      </el-form-item>  
      <el-form-item label="到货币" label-width="80px">  
        <el-select v-model="form.toCurrency" placeholder="选择货币">  
          <el-option v-for="currency in currencies" :key="currency" :label="currency" :value="currency" />  
        </el-select>  
      </el-form-item>  
      <el-form-item label="金额" label-width="80px">  
        <el-input v-model="form.amount" type="number" placeholder="输入金额" />  
      </el-form-item>  
      <el-form-item>  
        <el-button type="primary" @click="exchange">兑换</el-button>  
      </el-form-item>  
    </el-form>  
    <div v-if="result" class="result">  
      <p>兑换结果: {{ result }}</p>  
    </div>  
  </el-container>  
</template>  
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import axios from '../axios';
  
  interface ExchangeRate {
    fromCurrency: string;
    toCurrency: string;
    rate: number;
  }
  
  const form = ref({
    fromCurrency: '',
    toCurrency: '',
    amount: 0,
  });
  
  const result = ref<number | null>(null);
  const currencies = ref<string[]>([]);
  const rates = ref<ExchangeRate[]>([]);
  
  const fetchCurrencies = async () => {
    try{
      const response = await axios.get<ExchangeRate[]>('/exchangeRates');
      rates.value = response.data;
      currencies.value = [...new Set(response.data.map((rate: ExchangeRate) => [rate.fromCurrency, rate.toCurrency]).flat())];
    }catch(error){
      console.log('Failed to load currencies', error)
    }
  };
  
  const exchange = () => {
    const rate = rates.value.find(
      (rate) => rate.fromCurrency === form.value.fromCurrency && rate.toCurrency === form.value.toCurrency
    )?.rate;
  
    if (rate) {
      result.value = form.value.amount * rate;
    } else {
      result.value = null;
    }
  };
  
  onMounted(fetchCurrencies);
  </script>
  
  <style scoped>
  .exchange-form {  
  width: 100%;  
  max-width: 600px;  
  margin: 20px auto;  
  padding: 20px;  
  background-color: #f5f5f5;  
  border-radius: 4px;  
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);  
}  
  
.result {  
  margin-top: 20px;  
  padding: 20px;  
  background-color: #f0f0f0;  
  border-radius: 4px;  
  text-align: center;  
  font-size: 18px;  
}  
  </style>
</file>

<file path="FrontEnd/src/views/HomeView.vue">
<template>  
  <el-container class="home-container">  
    <div class="content-wrapper">  
      <h1 class="title">欢迎使用蓝鼠兑换</h1>  
      <p class="description">请选择上方的功能进行操作。</p>  
    </div>  
  </el-container>  
</template>  
  
<script setup lang="ts">   
</script>  
  
<style scoped>  
.home-container {  
  display: flex;  
  justify-content: center;  
  align-items: center;  
  height: 100vh; 
  background-color: #f5f5f5;
  padding: 20px; 
  box-sizing: border-box;
}  
  
.content-wrapper {  
  text-align: center;  
  max-width: 800px; 
}  
  
.title {  
  color: #333;  
  font-size: 36px;  
  font-weight: bold;  
  margin-bottom: 20px;   
}  
  
.description {  
  color: #666;  
  font-size: 18px; 
  line-height: 1.5;  
}  
</style>
</file>

<file path="FrontEnd/src/views/NewsDetailView.vue">
<template>
  <el-container>
    <el-main>
      <el-card v-if="article" class="article-detail">
        <h1>{{ article.Title }}</h1>
        <p>{{ article.Content }}</p>
        <div>
          <el-button type="primary" @click="likeArticle">点赞</el-button>
          <p>点赞数: {{ likes }}</p>
        </div>
      </el-card>
      <div v-else class="no-data">您必须登录/注册才可以阅读文章</div>
    </el-main>
  </el-container>
</template>

<script setup lang="ts">
import { ref, onMounted, onUpdated, onBeforeUpdate, onBeforeMount } from "vue";
import { useRoute } from "vue-router";
import axios from "../axios";
import type { Article, Like } from "../types/Article";

const article = ref<Article | null>(null);
const route = useRoute();
const likes = ref<number>(0)

const { id } = route.params;

const fetchArticle = async () => {
  try {
    const response = await axios.get<Article>(`/articles/${id}`);
    article.value = response.data;
  } catch (error) {
    console.error("Failed to load article:", error);
  }
};

const likeArticle = async () => {
  try {
    const res = await axios.post<Like>(`articles/${id}/like`)
    likes.value = res.data.likes
    await fetchLike()
  } catch (error) {
    console.log('Error Liking article:', error)
  }
};

const fetchLike = async ()=>{
  try{
    const res = await axios.get<Like>(`articles/${id}/like`)
    likes.value = res.data.likes
  }catch(error){
    console.log('Error fetching likes:', error)
  }
}

onMounted(fetchArticle);
onMounted(fetchLike)
</script>

<style scoped>
.article-detail {
  margin: 20px 0;
}

.no-data {
  text-align: center;
  font-size: 1.2em;
  color: #999;
}
</style>
</file>

<file path="FrontEnd/src/views/NewsView.vue">
<template>
  <el-container>
    <el-main>
      <div v-if="articles && articles.length">
        <el-card v-for="article in articles" :key="article.ID" class="article-card">
          <h2>{{ article.Title }}</h2>
          <p>{{ article.Preview }}</p>
          <el-button text @click="viewDetail(article.ID)">阅读更多</el-button>
        </el-card>
      </div>
      <div v-else class="no-data">您必须登录/注册才可以查看文章</div>
    </el-main>
  </el-container>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage } from 'element-plus';
import axios from '../axios';
import { useAuthStore } from '../store/auth';
import type { Article } from "../types/Article";

const articles = ref<Article[]>([]);
const router = useRouter();
const authStore = useAuthStore();

const fetchArticles = async () => {
  try {
    const response = await axios.get<Article[]>('/articles');
    articles.value = response.data;
  } catch (error) {
    console.error('Failed to load articles:', error);
  }
};

const viewDetail = (id: string) => {
  if (!authStore.isAuthenticated) {
    ElMessage.error('请先登录后再查看');
    return;
  }
  router.push({ name: 'NewsDetail', params: { id } });
};

onMounted(fetchArticles);
</script>

<style scoped>
.article-card {
  margin: 20px 0;
}

.no-data {
  text-align: center;
  font-size: 1.2em;
  color: #999;
}
</style>
</file>

<file path="FrontEnd/src/views/ProfileView.vue">
<template>
  <el-container class="profile-container">
    <el-card class="profile-card">
      <template #header>
        <div class="card-header">
          <span>个人资料</span>
        </div>
      </template>
      
      <el-form :model="form" label-width="100px" v-loading="loading">
        <el-form-item label="用户名">
          <el-input v-model="authStore.user!.username" disabled />
        </el-form-item>
        <el-form-item label="角色">
          <el-tag>{{ authStore.user?.role }}</el-tag>
        </el-form-item>

        <el-form-item label="昵称">
          <el-input v-model="form.nickname" placeholder="设置昵称" />
        </el-form-item>

        <el-form-item label="邮箱">
          <el-input v-model="form.email" placeholder="绑定邮箱" />
        </el-form-item>

        <el-form-item label="头像URL">
          <el-input v-model="form.avatar" placeholder="输入图片地址" />
          <div v-if="form.avatar" class="avatar-preview">
            <el-avatar :size="50" :src="form.avatar" />
          </div>
        </el-form-item>

        <el-divider content-position="left">修改密码 (留空则不修改)</el-divider>

        <el-form-item label="新密码">
          <el-input 
            v-model="form.password" 
            type="password" 
            placeholder="8位以上，含大小写字母和数字" 
            show-password
          />
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="handleUpdate">保存修改</el-button>
          <el-button @click="resetForm">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </el-container>
</template>

<script setup lang="ts">
import { ElMessage } from 'element-plus';
import { onMounted, reactive, ref } from 'vue';
import { useAuthStore } from '../store/auth';

const authStore = useAuthStore();
const loading = ref(false);

const form = reactive({
  nickname: '',
  email: '',
  avatar: '',
  password: ''
});

// 初始化表单数据
const initForm = () => {
  if (authStore.user) {
    form.nickname = authStore.user.nickname || '';
    form.email = authStore.user.email || '';
    form.avatar = authStore.user.avatar || '';
    form.password = ''; // 密码默认不回显
  }
};

onMounted(async () => {
  loading.value = true;
  // 确保获取最新数据
  await authStore.fetchProfile();
  initForm();
  loading.value = false;
});

const handleUpdate = async () => {
  // 构建 payload，如果密码为空字符串则不发送 password 字段
  const payload: any = {
    nickname: form.nickname,
    email: form.email,
    avatar: form.avatar
  };
  
  if (form.password) {
    payload.password = form.password;
  }

  try {
    loading.value = true;
    await authStore.updateProfile(payload);
    ElMessage.success('个人资料更新成功');
    form.password = ''; // 更新成功后清空密码框
  } catch (error: any) {
    ElMessage.error(error.message || '更新失败');
  } finally {
    loading.value = false;
  }
};

const resetForm = () => {
  initForm();
};
</script>

<style scoped>
.profile-container {
  display: flex;
  justify-content: center;
  padding: 40px 20px;
}
.profile-card {
  width: 100%;
  max-width: 600px;
}
.avatar-preview {
  margin-top: 10px;
}
</style>
</file>

<file path="FrontEnd/src/App.vue">
<template>
  <el-container>
    <el-header>
      <el-menu 
        :default-active="activeIndex" 
        class="el-menu-demo" 
        mode="horizontal" 
        :ellipsis="true" 
        @select="handleSelect"
      >
        <el-menu-item index="home">首页</el-menu-item>
        <el-menu-item index="currencyExchange">货币兑换</el-menu-item>
        <el-menu-item index="news">新闻资讯</el-menu-item>
        
        <!-- 管理员菜单 -->
        <el-submenu index="admin" v-if="authStore.user?.role === 'admin'">
          <template #title>
            <el-icon><Setting /></el-icon>
            管理员
          </template>
          <el-menu-item index="adminUsers">用户管理</el-menu-item>
        </el-submenu>
        
        <!-- 用户相关菜单 -->
        <div class="user-menu" v-if="authStore.isAuthenticated">
          <el-submenu index="user">
            <template #title>
              <el-avatar 
                :size="32" 
                :src="authStore.user?.avatar" 
                style="margin-right: 8px;"
              >
                {{ authStore.user?.username?.charAt(0)?.toUpperCase() }}
              </el-avatar>
              {{ authStore.user?.nickname || authStore.user?.username }}
              <el-tag v-if="authStore.user?.role === 'admin'" size="small" type="danger" style="margin-left: 8px;">
                管理员
              </el-tag>
            </template>
            <el-menu-item index="profile">个人资料</el-menu-item>
            <el-menu-item index="logout">退出登录</el-menu-item>
          </el-submenu>
        </div>
        
        <div class="auth-menu" v-else>
          <el-menu-item index="login">登录</el-menu-item>
          <el-menu-item index="register">注册</el-menu-item>
        </div>
      </el-menu>
    </el-header>
    
    <el-main>
      <router-view></router-view>
    </el-main>
  </el-container>
</template>

<script setup lang="ts">
import { Setting } from '@element-plus/icons-vue';
import { onMounted, ref, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { useAuthStore } from './store/auth';

const router = useRouter();
const route = useRoute();
const authStore = useAuthStore();
const activeIndex = ref('home');

// 监听路由变化高亮菜单
watch(route, (newRoute) => {
  updateActiveIndex(newRoute);
});

// 应用加载时，如果已登录但没有用户信息，尝试获取一次
onMounted(() => {
  updateActiveIndex(route);
  if (authStore.isAuthenticated && !authStore.user) {
    authStore.fetchProfile();
  }
});

const updateActiveIndex = (currentRoute: any) => {
  const routeName = currentRoute.name?.toString().toLowerCase();
  switch (routeName) {
    case 'home':
      activeIndex.value = 'home';
      break;
    case 'currencyexchange':
      activeIndex.value = 'currencyExchange';
      break;
    case 'news':
    case 'newsdetail':
      activeIndex.value = 'news';
      break;
    case 'profile':
      activeIndex.value = 'profile';
      break;
    case 'adminusers':
      activeIndex.value = 'adminUsers';
      break;
    default:
      activeIndex.value = 'home';
  }
};

const handleSelect = (key: string) => {
  switch (key) {
    case 'logout':
      authStore.logout();
      router.push({ name: 'Home' });
      break;
    case 'profile':
      router.push({ name: 'Profile' });
      break;
    case 'adminUsers':
      router.push({ name: 'AdminUsers' });
      break;
    case 'home':
      router.push({ name: 'Home' });
      break;
    case 'currencyExchange':
      router.push({ name: 'CurrencyExchange' });
      break;
    case 'news':
      router.push({ name: 'News' });
      break;
    case 'login':
      router.push({ name: 'Login' });
      break;
    case 'register':
      router.push({ name: 'Register' });
      break;
  }
};
</script>

<style scoped>
.el-menu-demo {
  line-height: 60px;
  display: flex;
  justify-content: space-between;
}

.user-menu {
  display: flex;
  align-items: center;
}

.auth-menu {
  display: flex;
}
</style>
</file>

<file path="FrontEnd/src/axios.ts">
import axios from 'axios';
import { ElMessage } from 'element-plus';
import { useAuthStore } from './store/auth';

const instance = axios.create({
  baseURL: 'http://localhost:3080/api',
});

// 请求拦截器
instance.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = token;
  }
  return config;
});

// 响应拦截器
instance.interceptors.response.use(
  response => {
    return response;
  },
  error => {
    if (error.response?.status === 401) {
      // token 过期或无效
      const authStore = useAuthStore();
      authStore.logout();
      ElMessage.error('登录已过期，请重新登录');
      window.location.href = '/login';
    } else if (error.response?.status === 403) {
      // 权限不足
      ElMessage.error('权限不足，无法访问此功能');
      if (window.location.pathname !== '/') {
        window.location.href = '/';
      }
    } else if (error.response?.status >= 500) {
      ElMessage.error('服务器错误，请稍后重试');
    }
    return Promise.reject(error);
  }
);

export default instance;
</file>

<file path="FrontEnd/src/main.ts">
import * as ElementPlusIconsVue from '@element-plus/icons-vue';
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css';
import { createPinia } from 'pinia';
import { createApp } from 'vue';
import App from './App.vue';
import router from './router';

const app = createApp(App);

// 注册所有图标
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component);
}

app.use(createPinia());
app.use(ElementPlus);
app.use(router);
app.mount('#app');
</file>

<file path="FrontEnd/src/shims-vue.d.ts">
// client/src/shims-vue.d.ts
declare module '*.vue' {
    import { DefineComponent } from 'vue';
    const component: DefineComponent<{}, {}, any>;
    export default component;
  }
</file>

<file path="FrontEnd/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="FrontEnd/__VLS_types.d.ts">
// @ts-nocheck

type __VLS_IntrinsicElements = __VLS_PickNotAny<import('vue/jsx-runtime').JSX.IntrinsicElements, __VLS_PickNotAny<JSX.IntrinsicElements, Record<string, any>>>;
type __VLS_Element = __VLS_PickNotAny<import('vue/jsx-runtime').JSX.Element, JSX.Element>;

type __VLS_IsAny<T> = 0 extends 1 & T ? true : false;
type __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;

type __VLS_Prettify<T> = { [K in keyof T]: T[K]; } & {};

type __VLS_OmitKeepDiscriminatedUnion<T, K extends keyof any> =
	T extends any
		? Pick<T, Exclude<keyof T, K>>
		: never;

type __VLS_GlobalComponents =
	__VLS_PickNotAny<import('vue').GlobalComponents, {}>
	& __VLS_PickNotAny<import('@vue/runtime-core').GlobalComponents, {}>
	& __VLS_PickNotAny<import('@vue/runtime-dom').GlobalComponents, {}>
	& Pick<typeof import('vue'),
		'Transition'
		| 'TransitionGroup'
		| 'KeepAlive'
		| 'Suspense'
		| 'Teleport'
	>;

declare const __VLS_intrinsicElements: __VLS_IntrinsicElements;

// v-for
declare function __VLS_getVForSourceType(source: number): [number, number, number][];
declare function __VLS_getVForSourceType(source: string): [string, number, number][];
declare function __VLS_getVForSourceType<T extends any[]>(source: T): [
	T[number], // item
	number, // key
	number, // index
][];
declare function __VLS_getVForSourceType<T extends { [Symbol.iterator](): Iterator<any> }>(source: T): [
	T extends { [Symbol.iterator](): Iterator<infer T1> } ? T1 : never, // item 
	number, // key
	undefined, // index
][];
declare function __VLS_getVForSourceType<T>(source: T): [
	T[keyof T], // item
	keyof T, // key
	number, // index
][];

declare function __VLS_getSlotParams<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>;
declare function __VLS_getSlotParam<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>[0];
declare function __VLS_directiveFunction<T>(dir: T):
	T extends import('vue').ObjectDirective<infer E, infer V> | import('vue').FunctionDirective<infer E, infer V> ? (value: V) => void
	: T;
declare function __VLS_withScope<T, K>(ctx: T, scope: K): ctx is T & K;
declare function __VLS_makeOptional<T>(t: T): { [K in keyof T]?: T[K] };

type __VLS_SelfComponent<N, C> = string extends N ? {} : N extends string ? { [P in N]: C } : {};
type __VLS_WithComponent<N0 extends string, LocalComponents, N1 extends string, N2 extends string, N3 extends string> =
	N1 extends keyof LocalComponents ? N1 extends N0 ? Pick<LocalComponents, N0> : { [K in N0]: LocalComponents[N1] } :
	N2 extends keyof LocalComponents ? N2 extends N0 ? Pick<LocalComponents, N0> : { [K in N0]: LocalComponents[N2] } :
	N3 extends keyof LocalComponents ? N3 extends N0 ? Pick<LocalComponents, N0> : { [K in N0]: LocalComponents[N3] } :
	N1 extends keyof __VLS_GlobalComponents ? N1 extends N0 ? Pick<__VLS_GlobalComponents, N0> : { [K in N0]: __VLS_GlobalComponents[N1] } :
	N2 extends keyof __VLS_GlobalComponents ? N2 extends N0 ? Pick<__VLS_GlobalComponents, N0> : { [K in N0]: __VLS_GlobalComponents[N2] } :
	N3 extends keyof __VLS_GlobalComponents ? N3 extends N0 ? Pick<__VLS_GlobalComponents, N0> : { [K in N0]: __VLS_GlobalComponents[N3] } :
	{ [K in N0]: unknown }

type __VLS_FillingEventArg_ParametersLength<E extends (...args: any) => any> = __VLS_IsAny<Parameters<E>> extends true ? -1 : Parameters<E>['length'];
type __VLS_FillingEventArg<E> = E extends (...args: any) => any ? __VLS_FillingEventArg_ParametersLength<E> extends 0 ? ($event?: undefined) => ReturnType<E> : E : E;
declare function __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K):
	T extends new (...args: any) => any
	? (props: (K extends { $props: infer Props } ? Props : any) & Record<string, unknown>, ctx?: {
		attrs?: any,
		slots?: K extends { $slots: infer Slots } ? Slots : any,
		emit?: K extends { $emit: infer Emit } ? Emit : any
	}) => __VLS_Element & { __ctx?: typeof ctx & { props?: typeof props; expose?(exposed: K): void; } }
	: T extends () => any ? (props: {}, ctx?: any) => ReturnType<T>
	: T extends (...args: any) => any ? T
	: (_: {} & Record<string, unknown>, ctx?: any) => { __ctx?: { attrs?: any, expose?: any, slots?: any, emit?: any, props?: {} & Record<string, unknown> } };
declare function __VLS_elementAsFunctionalComponent<T>(t: T): (_: T & Record<string, unknown>, ctx?: any) => { __ctx?: { attrs?: any, expose?: any, slots?: any, emit?: any, props?: T & Record<string, unknown> } };
declare function __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): Parameters<T>['length'] extends 2 ? [any] : [];
declare function __VLS_pickEvent<E1, E2>(emitEvent: E1, propEvent: E2): __VLS_FillingEventArg<
	__VLS_PickNotAny<
		__VLS_AsFunctionOrAny<E2>,
		__VLS_AsFunctionOrAny<E1>
	>
> | undefined;
declare function __VLS_pickFunctionalComponentCtx<T, K>(comp: T, compInstance: K): __VLS_PickNotAny<
	'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: infer Ctx } ? Ctx : never : any
	, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any
>;
type __VLS_FunctionalComponentProps<T, K> =
	'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: { props?: infer P } } ? NonNullable<P> : never
	: T extends (props: infer P, ...args: any) => any ? P :
	{};
type __VLS_AsFunctionOrAny<F> = unknown extends F ? any : ((...args: any) => any) extends F ? F : any;

declare function __VLS_normalizeSlot<S>(s: S): S extends () => infer R ? (props: {}) => R : S;

/**
 * emit
 */
// fix https://github.com/vuejs/language-tools/issues/926
type __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;
type __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R
	? U extends T
	? never
	: __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R)
	: never;
type __VLS_OverloadUnion<T> = Exclude<
	__VLS_OverloadUnionInner<(() => never) & T>,
	T extends () => never ? never : () => never
>;
type __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F
	? F extends (event: infer E, ...args: infer A) => any
	? { [K in E & string]: (...args: A) => void; }
	: never
	: never;
type __VLS_NormalizeEmits<T> = __VLS_Prettify<
	__VLS_UnionToIntersection<
		__VLS_ConstructorOverloads<T> & {
			[K in keyof T]: T[K] extends any[] ? { (...args: T[K]): void } : never
		}
	>
>;
</file>

<file path="FrontEnd/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ExchangeApp</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
</file>

<file path="FrontEnd/package.json">
{
  "name": "exchangeappdemo",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.7.3",
    "element-plus": "^2.7.4",
    "pinia": "^2.1.7",
    "router": "^1.3.8",
    "vant": "^4.9.0",
    "vue": "^3.4.21",
    "vue-router": "^4.3.2"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@types/node": "^20.12.13",
    "@types/vue-router": "^2.0.0",
    "@typescript-eslint/eslint-plugin": "^7.11.0",
    "@typescript-eslint/parser": "^7.11.0",
    "@vitejs/plugin-vue": "^5.0.4",
    "@vue/cli-plugin-typescript": "^5.0.8",
    "@vue/eslint-config-typescript": "^13.0.0",
    "typescript": "^5.2.2",
    "vite": "^5.4.0",
    "vue-tsc": "^2.0.6"
  },
  "main": "index.js",
  "author": "",
  "license": "ISC",
  "description": ""
}
</file>

<file path="FrontEnd/tsconfig.json">
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "strict": true,
    "jsx": "preserve",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["node", "vite/client"]
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"]
}
</file>

<file path="FrontEnd/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="FrontEnd/vite.config.ts">
// https://vitejs.dev/config/
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3080',
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
});
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: exchange-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: 123
      MYSQL_DATABASE: exchangeApp
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10
      start_period: 30s

  redis:
    image: redis:7.0-alpine
    container_name: exchange-redis
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      timeout: 10s
      retries: 5
      start_period: 10s

  backend:
    build:
      context: ./BackEnd
      dockerfile: Dockerfile
    container_name: exchange-backend
    ports:
      - "3080:3080"  # 这里已经正确映射了
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - DB_USER=root
      - DB_PASSWORD=123
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_NAME=exchangeApp
      - REDIS_ADDR=redis:6379
      - REDIS_PASSWORD=
      - REDIS_DB=0
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
</file>

<file path="package.json">
{
  "dependencies": {
    "@element-plus/icons-vue": "^2.3.2"
  }
}
</file>

</files>
